BUILD AUTOMATION & CI/CD W JENKINS

let dedicated sever to execute tests and build images automatically

Jenkins is buid automation tool that you install on dedicated server with UI
- run tests
- build artifacts
- publish artifacts
- deploy artifacts
- send notifications
integrates with other tools (Docker, Repos, Build tools, deployment servers ...) via plugins

2 Roles for Jenkins 
- admin
    manages Jenkins
    sets up cluster
    installs plugins
    backup data
- user
    create actual jobs to run workflows
    
Depdending on app, need to have different Tools installed and configured on Jenkins
-> plugins (install then configure then add as step in job build)
-> directly on server (more flexibility)

/jobs -> where jobs stored in jenkins
/workspace -> where git repos stored in jenkins when checked out in jobs

Make Docker available in Jenkins -> attach volume to Jenkins from the host file (mount Docker runtime directory from host server into the container as a volume)

Pipeline Job vs Freestyle Job (= pipeline is superset of freestyle jobs)
-> Freestyle Job with 1 job/step (limited as config via UI not scripting/limited to input fields of Plugin: not suitable for complex workflows)
-> Pipeline suitable for CI/CD, scripting - pipeline as code (exec steps in parallel, need user input, conditional statement, set variables, easier to manage and change over time)

-> Pipeline script written in Groovy
-> Best practice to have Pipeline script in Git repo

Jenkinsfile syntax
-> Create Jenkinsfile that runs script
-> required fields:
"pipeline" - top level
"agent" - where to exec
"stages" and "steps" - where scripts run
    conditionals "when" "expression"
"post" - exec some logic after all stages exec
  conditionals "always" "success" "failure"
"tools" - access build tools (supports maven, gradle, jdk)
"parameters" (params.name) -> Build with parameters option in Jenkisn GUI
    string(name, defaultValue, description)
    choice(name, choices, description)
    booleanParam(name, defaultValue, description)
 "input" - prompts user for input
    "message"
    "ok"
    "parameters"
 
ENV
check which vars available from Jenkins /env-vars.html
 -> eg. env BRANCH_NAME available out of box ('dev' 'master' etc)
can create own env vars 
"environment" 
interpolatation in groovy "this is my ${ENV_VAR}"

Credentials
1. Binds creds to env
can define credentials in Jenkins GUI
"credentials("credentialsId")" binds creds to env var
need "Credentials Binding" Plugin 
2. withCredentials([]) {}

Using external Groovy scripts
"script"
load "script.groovy" into var
call functions defined in groovy script using var.fn()
all env vars available in Jenkinsfile are available in groovy script

Replay option in Jenkins GUI allows to test different build scripts without comitting changes to git repo
Can rerun a particular stage

Multibranch Pipeline
- need pipelines for all branches
- need different behaviour based on branch
- creates piepline for all branches that have Jenkinsfile

Credentials in Jenkins
- scopes: system (only available on Jenkins server), global (access everywhere), project (scope to project, onyl available for multibranch pipeline)
- type (username w password, SSH, secret file etc.)

Jenkins Shared Library (share logic across projects)
- extension to pipeline
- has own repo
- reference shared logic in Jenkinsfile
- can config in Jenkins to be shared globally or scoped to project (scope defined in Jenkinsfile)
Folder structure of shared lib
- vars folder - fn we call from Jenkinsfile, each its own groovy file
- src folder - helper code
- resources folder - external lib, non groovy files



TO COPY OVER TO DEMO READ.ME (WHEN READY)
1. Create server on DigitalOcean and config firewall rule for Jenkins. Install Docker

2. Pull and run Jenkins container -> docker run -p 8080:8080 -p 50000:50000 -d -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts

3. Install build tools in Jenkins container (using Jenkins plugin manager and/or installing directly on server on which Jenkins container is running)

4. Create a simple job in Jenkins and run a build
IMG1

5. Configure Jenkins access to Source Code Mgmnt (Github in this case)
IMG2

6. Run another build for the same job and verify that repo was checked out
IMG3
IMG4

7. Add 'package' command from maven to build steps, when checking out branch on github repo, and verify that artifact was built successfully
IMG5

8. Access Docker from Jenkins container -> need to mount Docker runtime directory from host server into the container as a volume
docker run -p 8080:8080 -p 50000:50000 -d -v jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker --name jenkins jenkins/jenkins:lts

9. Give jenkins user permissions to read and write Docker /var/run/docker.sock
as root user run: chmod 666 /var/run/docker.sock

10. Build Docker image from Jenkins using Dockerfile
IMG6
IMG7

11. Create repo on Dockerhub and add credentials to Jenkins
IMG8

12. Add Docker scripts in Jenkins job build to login to Dockerhub using credentials added and push to the Dockerhub repo (for credentials use secret texts to create variables used in commands for login)
IMG9
IMG10

13. Run the build and check in Dockerhub repo that image is there
IMG11
IMG12

14. Create pipeline job that connects to Git repo
IMG13

15. Create Jenkinsfile in configured repo
IMG14

16. Build pipeline job
IMG15

17. Enhance pipeline job to build jar and push to Docker hub
IMG16
IMG17

18. Create multibranch pipeline
IMG18
IMG19

19. Create Jenkins Shared Library
IMG20

20. Configure Jenkins to be able to use Shared Library
IMG21

21. Use Shared Library in Jenkinsfile
IMG22

22. Refactor Jenkins Shared Library & Jenkinsfile to use groovy classes and separate functions, and scope to project







